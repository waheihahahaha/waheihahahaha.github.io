---
title: 快速排序的 JavaScript 实现
date: 2019-04-25 16:51:18
comments: true #是否可评论
categories: quickSort #分类
toc: true #是否显示文章目
tags:   #标签
	- 快排
	- JavaScript
---
快速排序的实例及代码
<!-- more -->
# 介绍

## JavaScript
JavaScript 有时缩写为JS，是高级语言Java 运用于网页中增强网页功能的一种脚本语言。
本文是用JavaScript 语言实现快速排序算法的。
## 排序
指在计算机内部把一组“无序”的记录序列按照递增或者递减的方式排列起来。
## 排序算法
排序算法则是使得这组“无序”的序列“按序”排列起来的方法。
排序的方法有很多，快速排序、希尔排序、堆排序、冒泡排序等等，这些方法被称为排序算法。
在处理大量数据时，一份优秀的算法可以节省大量的资源，尤其是面对大量数据的排序时，算法有着得天独厚的优点。
## 快速排序
快速排序是最常见的排序算法中的一种，与其他排序算法比较来说，使用较广泛，速度也较快。在面对大量数据时，快速排序的复杂度为 nlgn，是已知算法中复杂度最小的，也就是说数据量够大时，使用快速排序算法是最省事的。



# 快速排序算法步骤及举例
## 快速排序步骤
***第一步***：选取一个基准值，一般取序列的第一个元素作为基准值，并把此基准值存入变量X中，指定两个指针，一个 begin 指针指向序列的起始位置，一个 end 指针指向序列终点位置
***第二步***：end 指针从序列右侧往左找一个比基准值小的值停下来，并把值赋值给 begin 指针指向的位置；接下来 begin 指针开始移动，从序列左侧往右找一个比基准值大的值停下来，并把值赋值给 end 指针指向的位置，直到两指针相遇，把变量X插入分界处，至此就完成了一趟快排。
***第三步***：通过第一趟快排后，序列被划分为了两个子表，且基准值左侧的元素均小于基准值，基准值右侧的值均大于基准值，分别对左子表和右子表继续按第一步和第二步规则进行分割，知道所有子表长度不超过1为止，也就完成了快速排序，整个数据变成有序序列。

## 举例
采用快速排序，对下列无序序列进行排序（下列方法也成为挖坑法）：

| 5 | 4 | 7 | 6 | 3 | 8 | 2 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|begin |  |  |  |  |  | end|

第一步，选一个基准值，这里选序列中的第一个元素 5，作为基准值且存入变量X中：X = 5，序列第一个值为空，指定两个指针，一个 begin 指针指向起始位置，一个 end 指针指向终点位置：

| 空 | 4 | 7 | 6 | 3 | 8 | 2 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|begin |  |  |  |  |  | end|

此时，begin 指针指向 空，end 指针指向 2 位置

第二步，end 指针从序列最右侧（即 2 位置处）往左找一个比基准值 X = 5 小的值来填这个坑（空），右边第一个值为 2 ， 2 < 5 ,此时序列为：

| 2 | 4 | 7 | 6 | 3 | 8 | 空 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|begin |  |  |  |  |  | end|

此时，begin 指针指向 2 位置，end 指针指向 空 

第三步，begin 指针 从序列左（即 2位置处）往右找一个比基准值 X = 5 大的值来填这个坑，左边第三个数为 7， 7 > 5 ,此时序列为：

| 2 | 4 | 空 | 6 | 3 | 8 | 7 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|  |  | begin |  |  |  | end|

此时，begin 指针指向 空 ，end 指针指向 7 位置

第四步，end 指针 从序列右（即 7 位置处）往左找一个比基准值 X = 5 小的值来填这个坑，右边第三个值为 3 ， 3 < 5 ,此时序列为：


| 2 | 4 | 3 | 6 | 空 | 8 | 7 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|  |  | begin |  | end |  |  |


此时，begin 指针指向 3 位置，end 指针指向 空

第五步，begin 指针 从序列左（即 3 位置处）往右找一个比基准值 X = 5 大的值来填这个坑，左边第四个数为 6， 7 > 5 ,此时序列为：


| 2 | 4 | 3 | 空 | 6 | 8 | 7 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|  |  |  | begin | end |  |  |


此时，begin 指针指向 空， end 指针指向 6位置
第六步，begin 指针指向 空，end 指针指向 6 位置，且 begin 指针和 end 指针相遇，到此快排第一趟完成，把基准值 5 （第一趟排序的基准值，写作基准值①）插入空格得到序列：

| 2 | 4 | 3 | 5（基准值①） | 6 | 8 | 7 |
|--|--|--|--|--|--|-

通过第一趟快排后，序列就被划分成了两个子表，且基准值左侧的元素均小于基准值，右侧的元素均大于基准值

第七步，把基准值左侧和右侧的子表采用同样的方法进行排序
左侧序列

| 2 | 4 | 3 |
|--|--|--|

右侧序列


| 6 | 8 | 7 |
|--|--|--|


采用递归方法则第七步得到


| 2（基准值 ② ） | 4 | 3 | 5（基准值①） | 6 | 8 | 7 |
|--|--|--|--|--|--|--|


第八步，


| 2（基准值②） | 3 | 4（基准值③）| 5（基准值①） | 6 | 8 | 7 |
|--|--|--|--|--|--|--|

第九步，

| 2（基准值②） | 3 | 4（基准值③）| 5（基准值①） | 6（基准值④） | 8 | 7 |
|--|--|--|--|--|--|--|

第十步，


| 2（基准值②） | 3 | 4（基准值③）| 5（基准值①） | 6（基准值④） | 7 | 8（基准值⑤） |
|--|--|--|--|--|--|--|

这时，排序完成

## 上代码

```javascript

quickSort(arr){                        // 快速排序挖坑法，arr 为未排序数组
      if (arr.length <= 1) {           // 传入的数组的长度小于等于1，排序完成      
      	return arr;
      }
      var x = arr[0]                   // 选择序列的第一个元素作为基准值
      arr[0] = ''                      // 基准值所在索引对应的值设为空值
      let i = 0                        // 前指针指向数组开始
      let j = arr.length - 1           // 后指针指向数组末
      while (i < j) {                  // 前指针指向的索引小于后指针时，循环，否则前后指针相遇，排序完成一趟，退出循环
        while (i < j && arr[j] > x) {  // 后指针移动，后指针指向的索引大于前指针同时指向的e值大于基准值时，后指针往前走一步，循环，条件有一不满足，退出循环
          j --
        }
        if (arr[j] <= x) {             // 退出循环时，后指针指向的值若小于基准值，把当前值赋值给左侧空值（填坑），同时当前索引对应的值设为空（挖坑）
          arr[i] = arr[j]   
          arr[j] = ''
        }
        while (i < j && arr[i] < x) {  // 前指针移动，前指针指向的索引小于后指针同时指向的值大于基准值，前指针往后走一步，循环，条件之一不满足，退出循环
          i ++
        }
        if (arr[i] >= x) {             // 退出循环时，前指针指向的值若大于基准值，把当前值赋值给右侧空值（填坑），同时当前索引对应的值设为空（挖坑）
          arr[j] = arr[i]
          arr[i] = ''
        }
      }
      let a = arr.indexOf('')         // 此时，前后置镇相遇，第一趟排序完成，寻找空值所在位置，并把基准值填入
      arr[a] = x
      
      let left = arr.slice(0, a)      // 把基准值左侧的值看为一个新的数组 left
      let right = arr.slice(a+1, arr.length+1)   // 基准值右侧的值看为一个新的数组 right
      // 采用递归的方法，分别对上述左子表和右子表继续按上述规则执行，并用 .concat 连接起来
      return this.quickSort(left).concat(x, this.quickSort(right))
    },
```

使用的时候，直接调用函数 quickSort() 就可以了。
比如说对上文中的例子使用此代码：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190425161649723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE3NDIyNQ==,size_16,color_FFFFFF,t_70)



